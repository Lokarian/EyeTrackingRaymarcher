// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel SideBySide
#pragma kernel LeftEyeOnly
#pragma enable_d3d11_debug_symbols

RWTexture2D<float4> textureOut;
uint2 resolution;
float4x4 viewFrustrum;
float3 rightEyePosition;
float3 leftEyePosition;
float normalEpsilon = 0.001f;
float marchEpsilon = 0.001f;
float sphereSize = 2.0f;
int maxIterations = 500000;

const float PI = 3.14159265359f;

const int _OR = 0;
const int _AND = 1;
const int _NOT = 2;
const int _SPHERE = 3;
const int _TORUS = 4;
const int _SMOOTHINTERSECTS = 5;
const int _SMOOTHUNION = 6;
const int _SMOOTHDIFFERENCE = 7;
const int _CUBE = 8;


struct GeneralTreeElement
{
    int nodeType;
    float4x4 translation;
    float3 color;
    float3 a;
    float3 b;
};

struct LinearTreeStack
{
    float distance;
    float4 color;
};

//RWStructuredBuffer<LinearTreeStack> stackContext;
//LinearTreeStack stackContext[25];
//int stackPointer = 0;
StructuredBuffer<GeneralTreeElement> distanceTree;
int distanceTreeLength;

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

    textureOut[id.xy] = float4(id.x & id.y, (id.x & 15) / 15.0, (id.y & 15) / 15.0, 0.0);
}

LinearTreeStack makeLinearTreeStack(float distance, float4 color)
{
    LinearTreeStack element;
    element.distance = distance;
    element.color = color;
    return element;
}


float logicalAND(float d1, float d2)
{
    return max(d1, d2);
}

float logicalOR(float d1, float d2)
{
    return min(d1, d2);
}

float logicalNOT(float d)
{
    return -d;
}

float getDistanceCirlce(float3 p)
{
    return length(p) - 0.5f;
}

float getDistanceTorus(float3 p, float2 r1r2)
{
    float2 q = float2(length(p.xz) - r1r2.x, p.y);
    return length(q) - r1r2.y;
}

float smoothIntersectSDF(float d1, float d2, float k)
{
    float h = clamp(0.5 - 0.5 * (d1 - d2) / k, 0., 1.);
    return lerp(d1, d2, h) + k * h * (1. - h);
}
 
float smoothUnionSDF(float d1, float d2, float k)
{
    float h = clamp(0.5 + 0.5 * (d1 - d2) / k, 0., 1.);
    return lerp(d1, d2, h) - k * h * (1. - h);
}
 
float smoothDifferenceSDF(float d1, float d2, float k)
{
    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0., 1.);
    return lerp(d1, -d2, h) + k * h * (1. - h);
}

float getDistanceCube(float3 p)
{
    float3 q = abs(p) - 0.5;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}



//LinearTreeStack pop()
//{
//    return stackContext[stackPointer--];
//}

//void push(LinearTreeStack e)
//{
//    stackContext[stackPointer++] = e;
//}

//LinearTreeStack evaluateNode(GeneralTreeElement element, float3 position)
//{
//    LinearTreeStack c1;
//    LinearTreeStack c2;
//    LinearTreeStack ret;
//    [branch]
//    switch (element.nodeType)
//    {
//    case 0: //_OR
//        c1 = pop();
//        c2 = pop();
//        ret = (makeLinearTreeStack(logicalAND(c1.distance, c2.distance), float4(1.0f, 0.0f, 0.0f, 1.0f)));
//        break;
//    case 1: //_AND
//        c1 = pop();
//        c2 = pop();
//        ret = (makeLinearTreeStack(logicalAND(c1.distance, c2.distance), float4(1.0f, 0.0f, 0.0f, 1.0f)));
//        break;
//    case 3: //_SPHERE
//        ret = makeLinearTreeStack
//        (getDistanceCirlce(mul(element.translation, float4(position, 1.0)).xyz, element.a.x),
//         float4(element.color, 1.0f));
//        break;
//    case 4: //_TORUS
//        ret = makeLinearTreeStack
//        (getDistanceTorus(mul(element.translation, float4(position, 1.0)).xyz, element.a.xy),
//         float4(element.color, 1.0f));
//        break;
//    default:
//        ret = makeLinearTreeStack(0.0f, float4(1.0f, 0.0f, 1.0f, 1.0f));
//        break;
//    }
//    return ret;
//}

//float getDistanceFromTree(float3 p)
//{
//    GeneralTreeElement element;
//    for (uint i = 0; i < 3; i++)
//    {
//        element = distanceTree[i];
//        push(evaluateNode(element, p));
//    }
//    return pop().distance;
//}

float getDistanceFromTreeCompact(float3 position)
{
    LinearTreeStack stackContext[25];
    int stackPointer = 0;
    GeneralTreeElement element;
    for (uint i = 0; i < distanceTreeLength; i++)
    {
        element = distanceTree[i];
        LinearTreeStack c1;
        LinearTreeStack c2;
        [branch]
        switch (element.nodeType)
        {
            case 0: //_OR
                c1 = stackContext[--stackPointer];
                c2 = stackContext[--stackPointer];
                stackContext[stackPointer++] = (makeLinearTreeStack(logicalOR(c1.distance, c2.distance), float4(1.0f, 0.0f, 0.0f, 1.0f)));
                break;
            case 1: //_AND
                c1 = stackContext[--stackPointer];
                c2 = stackContext[--stackPointer];
                stackContext[stackPointer++] = (makeLinearTreeStack(logicalAND(c1.distance, c2.distance), float4(1.0f, 0.0f, 0.0f, 1.0f)));
                break;
            case 2: //_NOT
                c1 = stackContext[--stackPointer];
                stackContext[stackPointer++] = (makeLinearTreeStack(logicalNOT(c1.distance), c1.color));
                break;
            case 3: //_SPHERE
                stackContext[stackPointer++] = (makeLinearTreeStack(getDistanceCirlce(mul(element.translation, float4(position, 1.0)).xyz),
         float4(element.color, 1.0f)));
                break;
            case 4: //_TORUS
                stackContext[stackPointer++] = (makeLinearTreeStack
        (getDistanceTorus(mul(element.translation, float4(position, 1.0)).xyz, element.a.xy),
         float4(element.color, 1.0f)));
                break;
            case 5: //_SMOOTHINTERSECTS
                c1 = stackContext[--stackPointer];
                c2 = stackContext[--stackPointer];
                stackContext[stackPointer++] = (makeLinearTreeStack(smoothIntersectSDF(c1.distance, c2.distance, element.a.x), float4(1.0f, 0.0f, 0.0f, 1.0f)));
                break;
            case 6: //_SMOOTHUNION
                c1 = stackContext[--stackPointer];
                c2 = stackContext[--stackPointer];
                stackContext[stackPointer++] = (makeLinearTreeStack(smoothUnionSDF(c1.distance, c2.distance, element.a.x), float4(1.0f, 0.0f, 0.0f, 1.0f)));
                break;
            case 7: //_SMOOTHDIFFERENCE
                c1 = stackContext[--stackPointer];
                c2 = stackContext[--stackPointer];
                stackContext[stackPointer++] = (makeLinearTreeStack(smoothDifferenceSDF(c1.distance, c2.distance, element.a.x), float4(1.0f, 0.0f, 0.0f, 1.0f)));
                break;
            case 8: //_CUBE
                stackContext[stackPointer++] = (makeLinearTreeStack(getDistanceCube(mul(element.translation, float4(position, 1.0)).xyz),
         float4(element.color, 1.0f)));
                break;
            default:
                stackContext[stackPointer++] = (makeLinearTreeStack(0.0f, float4(1.0f, 0.0f, 1.0f, 1.0f)));
                break;
        }
    }
    return stackContext[stackPointer - 1].distance;
}
float getDistance(float3 p)
{
    return getDistanceFromTreeCompact(p);
}

float3 getSurfaceNormal(float3 p)
{
    return normalize(getDistance(p) -
        float3(
            getDistance(p - float3(marchEpsilon, 0, 0)),
            getDistance(p - float3(0, marchEpsilon, 0)),
            getDistance(p - float3(0, 0, marchEpsilon))
        ));
}

float4 CastRay(float3 origin, float3 direction)
{
    bool finished = false;
    float3 marchPosition = origin;
    float3 marchDirection = normalize(direction);
    int iterations = 0;
    float smallestDistance = 1000000.0f;
    do
    {
        float distance = getDistance(marchPosition);
        if (distance < marchEpsilon)
        {
            //return float4(1.0, 0, 0, 1.0);
            return float4(getSurfaceNormal(marchPosition), 1.0f);
        }
        marchPosition += (marchDirection * distance);
        if (smallestDistance > distance)
        {
            smallestDistance = distance;
        }

        if (iterations > maxIterations)
        {
            return float4(1.0, 0.0, 1.0, 1.0);
        }
        if (length(marchPosition) > 1000f)
        {
            finished = true;
        }
        iterations++;
    }
    while (!finished);
    return float4(direction, 1.0);


    //float3 marchDirection = normalize(direction);
    //float4 colorOut = float4(1.0f, 1.0f, 1.0f, 1.0f);
    //float3 marchPosition = origin;
    //float distance = 0.0f;
    //float minDistance = 0;
    //for (int i = 0; i <= sphereSize; i++)
    //{
    //    minDistance += 1 / 10.0f;

    //}
    //float normalizedDistance = minDistance ;
    //colorOut.rgb = normalizedDistance;
    //return colorOut;

    //float angleToOrigin = acos(dot(normalize(direction), normalize(-origin)));
    //angleToOrigin = angleToOrigin / PI;
    //float3 marchPosition = origin;
    //float distance = 0.0f;
    //float minDistance = 1000.0f;

    //for (int i = 0; i <= sphereSize; i++)
    //{
    //    float distance = getDistance(origin + sphereSize * normalize(direction));
    //    minDistance = min(minDistance, distance);

    //}
    //return float4(angleToOrigin,angleToOrigin,angleToOrigin, 1.0);
}


float3 calculateViewRay(float2 pixelCoordinate, float isRightEye)
{
    return mul(viewFrustrum, float4(pixelCoordinate.x, pixelCoordinate.y, 1.0f, isRightEye)).xyz;
}


[numthreads(8, 8, 1)]
void SideBySide(uint3 id : SV_DispatchThreadID)
{
    uint2 pixelCoordinate = id.xy;
    float3 eyePosition;
    float isRightEye;
    if (pixelCoordinate.x < resolution.x / 2)
    {
        eyePosition = leftEyePosition;
        isRightEye = 0.0f;
    }
    else
    {
        eyePosition = rightEyePosition;
        isRightEye = 1.0f;
    }
    float2 realtiveCoordinate = float2(pixelCoordinate.x % (resolution.x / 2) / (float) (resolution.x / 2),
                                       pixelCoordinate.y / (float) resolution.y);
    float3 directionRay = calculateViewRay(realtiveCoordinate, isRightEye);
    float4 color = CastRay(eyePosition, directionRay);

    textureOut[id.xy] = color;
}

[numthreads(8, 8, 1)]
void LeftEyeOnly(uint3 id : SV_DispatchThreadID)
{
    uint2 pixelCoordinate = id.xy;
    float2 realtiveCoordinate = float2(pixelCoordinate.x / (float) resolution.x,
                                       pixelCoordinate.y / (float) resolution.y);
    float3 directionRay = calculateViewRay(realtiveCoordinate, 0.0f);
    float4 color = CastRay(leftEyePosition, directionRay);

    textureOut[id.xy] = color;
}
