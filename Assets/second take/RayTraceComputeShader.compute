// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel SideBySide
#pragma enable_d3d11_debug_symbols

RWTexture2D<float4> textureOut;
uint2 resolution;
float4x4 viewFrustrum;
float3 rightEyePosition;
float3 leftEyePosition;
float normalEpsilon = 0.001f;
float marchEpsilon = 0.001f;
float circleSize = 2.0f;
int maxIterations = 500000;

const float PI = 3.14159265359f;

const int _OR = 0;
const int _AND = 1;
const int _NOT = 2;
const int _CIRCLE = 3;
const int _TORUS = 4;

struct GeneralTreeElement
{
    int nodeType;
    float4x4 translation;
    float3 color;
    float3 a;
    float3 b;
};

struct LinearTreeStack
{
    float distance;
    float4 color;
};

LinearTreeStack stackContext[25];
int stackPointer = 0;
RWStructuredBuffer<GeneralTreeElement> distanceTree;
int distanceTreeLength;

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

    textureOut[id.xy] = float4(id.x & id.y, (id.x & 15) / 15.0, (id.y & 15) / 15.0, 0.0);
}

LinearTreeStack makeLinearTreeStack(float distance, float4 color)
{
    LinearTreeStack element;
    element.distance = distance;
    element.color = color;
    return element;
}


float logicalAND(float d1, float d2)
{
    return max(d1, d2);
}

float logicalOR(float d1, float d2)
{
    return min(d1, d2);
}

float getDistanceCirlce(float3 p, float r)
{
    return length(p) - circleSize;
}

float getDistanceTorus(float3 p, float2 r1r2)
{
    float2 q = float2(length(p.xz) - r1r2.x, p.y);
    return length(q) - r1r2.y;
}

float getDistance(float3 p)
{
    return getDistanceTorus(p, float2(circleSize, circleSize / 6));
}

LinearTreeStack pop()
{
    return stackContext[stackPointer--];
}

void push(LinearTreeStack e)
{
    stackContext[stackPointer++] = e;
}

LinearTreeStack evaluateNode(GeneralTreeElement element, float3 position)
{
    LinearTreeStack c1;
    LinearTreeStack c2;
    [branch] switch (element.nodeType)
    {
    case _AND:
        c1 = pop();
        c2 = pop();
        return (makeLinearTreeStack(logicalAND(c1.distance, c2.distance), float4(1.0f, 0.0f, 0.0f, 1.0f)));
    case _OR:
        c1 = pop();
        c2 = pop();
        return (makeLinearTreeStack(logicalAND(c1.distance, c2.distance), float4(1.0f, 0.0f, 0.0f, 1.0f)));
    case _CIRCLE:
        return makeLinearTreeStack(getDistanceCirlce(mul(element.translation, float4(position, 1.0)).xyz, element.a.x),
                                   float4(element.color, 1.0f));
    case _TORUS:
        return makeLinearTreeStack(getDistanceTorus(mul(element.translation, float4(position, 1.0)).xyz, element.a.xy),
                                   float4(element.color, 1.0f));
    default:
        return makeLinearTreeStack(0.0f, float4(1.0f, 0.0f, 1.0f, 1.0f));
    }
}

float getDistanceFromTree(float3 p)
{
    GeneralTreeElement element;
    for(uint i= 0; i < distanceTreeLength; i++)
    {
        element = distanceTree[i];
        push(evaluateNode(element, p));
    }
    return pop().distance;
}


float3 getSurfaceNormal(float3 p)
{
    return normalize(getDistance(p) -
        float3(
            getDistance(p - float3(marchEpsilon, 0, 0)),
            getDistance(p - float3(0, marchEpsilon, 0)),
            getDistance(p - float3(0, 0, marchEpsilon))
        ));
}

float4 CastRay(float3 origin, float3 direction)
{
    bool finished = false;
    float3 marchPosition = origin;
    float3 marchDirection = normalize(direction);
    int iterations = 0;
    float smallestDistance = 1000000.0f;
    do
    {
        float distance = getDistance(marchPosition);
        if (distance < marchEpsilon)
        {
            //return float4(1.0, 0, 0, 1.0);
            return float4(getSurfaceNormal(marchPosition), 1.0f);
        }
        marchPosition += (marchDirection * distance);
        if (smallestDistance > distance)
        {
            smallestDistance = distance;
        }

        if (iterations > maxIterations)
        {
            return float4(smallestDistance, smallestDistance, smallestDistance, 1.0);
        }

        iterations++;
    }
    while (!finished);
    return float4(direction, 1.0);


    //float3 marchDirection = normalize(direction);
    //float4 colorOut = float4(1.0f, 1.0f, 1.0f, 1.0f);
    //float3 marchPosition = origin;
    //float distance = 0.0f;
    //float minDistance = 0;
    //for (int i = 0; i <= circleSize; i++)
    //{
    //    minDistance += 1 / 10.0f;

    //}
    //float normalizedDistance = minDistance ;
    //colorOut.rgb = normalizedDistance;
    //return colorOut;

    //float angleToOrigin = acos(dot(normalize(direction), normalize(-origin)));
    //angleToOrigin = angleToOrigin / PI;
    //float3 marchPosition = origin;
    //float distance = 0.0f;
    //float minDistance = 1000.0f;

    //for (int i = 0; i <= circleSize; i++)
    //{
    //    float distance = getDistance(origin + circleSize * normalize(direction));
    //    minDistance = min(minDistance, distance);

    //}
    //return float4(angleToOrigin,angleToOrigin,angleToOrigin, 1.0);
}


float3 calculateViewRay(float2 pixelCoordinate, float isRightEye)
{
    return mul(viewFrustrum, float4(pixelCoordinate.x, pixelCoordinate.y, 1.0f, isRightEye)).xyz;
}

[numthreads(8, 8, 1)]
void SideBySide(uint3 id : SV_DispatchThreadID)
{
    uint2 pixelCoordinate = id.xy;
    float3 eyePosition;
    float isRightEye;
    if (pixelCoordinate.x < resolution.x / 2)
    {
        eyePosition = leftEyePosition;
        isRightEye = 0.0f;
    }
    else
    {
        eyePosition = rightEyePosition;
        isRightEye = 1.0f;
    }
    float2 realtiveCoordinate = float2(pixelCoordinate.x % (resolution.x / 2) / (float)(resolution.x / 2),
                                       pixelCoordinate.y / (float)resolution.y);
    float3 directionRay = calculateViewRay(realtiveCoordinate, isRightEye);
    float4 color = CastRay(eyePosition, directionRay);

    textureOut[id.xy] = color;
}

[numthreads(8, 8, 1)]
void LeftEyeOnly(uint3 id : SV_DispatchThreadID)
{
    uint2 pixelCoordinate = id.xy;
    float3 eyePosition;
    float isRightEye;
    if (pixelCoordinate.x < resolution.x / 2)
    {
        eyePosition = leftEyePosition;
        isRightEye = 0.0f;
    }
    else
    {
        eyePosition = rightEyePosition;
        isRightEye = 1.0f;
    }
    float2 realtiveCoordinate = float2(pixelCoordinate.x % (resolution.x / 2) / (float)(resolution.x / 2),
                                       pixelCoordinate.y / (float)resolution.y);
    float3 directionRay = calculateViewRay(realtiveCoordinate, isRightEye);
    float4 color = CastRay(eyePosition, directionRay);

    textureOut[id.xy] = color;
}
