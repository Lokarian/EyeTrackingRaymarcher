// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel SideBySide
#pragma kernel LeftEyeOnly
#pragma kernel AntiAliasing
#pragma enable_d3d11_debug_symbols

RWTexture2D<float4> textureOut;
uint2 resolution;
float4x4 viewFrustrum;
float3 rightEyePosition;
float3 leftEyePosition;
float normalEpsilon = 0.001f;
float marchEpsilon = 0.001f;
float sphereSize = 2.0f;
float softShadowFactor = 2.0f;
float shadowStartDistance = 2.0f;
int maxIterations = 500000;
int maxReflections = 0;
Texture2D<float4> _Skybox;
SamplerState sampler_Skybox;

float3 lightPosition = float3(10, 10, 10);
float3 lightColor = float3(1, 1, 1);
float ambientFactor = 1;
float shininess = 1;

static const float PI = 3.14159265359f;

const int _OR = 0;
const int _AND = 1;
const int _NOT = 2;
const int _SPHERE = 3;
const int _TORUS = 4;
const int _SMOOTHINTERSECTS = 5;
const int _SMOOTHUNION = 6;
const int _SMOOTHDIFFERENCE = 7;
const int _CUBE = 8;


struct GeneralTreeElement
{
    int nodeType;
    float4x4 translation;
    float3 color;
    float3 a;
    float3 b;
};

struct LinearTreeStack
{
    float distance;
    float4 color;
};

//RWStructuredBuffer<LinearTreeStack> stackContext;
//LinearTreeStack stackContext[25];
//int stackPointer = 0;
StructuredBuffer<GeneralTreeElement> distanceTree;
int distanceTreeLength;

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

    textureOut[id.xy] = float4(id.x & id.y, (id.x & 15) / 15.0, (id.y & 15) / 15.0, 0.0);
}

bool vecLessThen(float3 a, float3 b)
{
    return a.x * a.x + a.y * a.y + a.z * a.z < b.x * b.x + b.y * b.y + b.z * b.z;
}


LinearTreeStack makeLinearTreeStack(float distance, float4 color)
{
    LinearTreeStack element;
    element.distance = distance;
    element.color = color;
    return element;
}

float4 interpolateColorsWithAlpha(float4 c1,float4 c2)
{
    float interpolationFactor = c1.a / (c1.a + c2.a);
    return float4(lerp(c1.rgb, c2.rgb, interpolationFactor), max(c1.a, c2.a));
}

float logicalAND(float d1, float d2)
{
    return max(d1, d2);
}

LinearTreeStack logicalANDWithColor(LinearTreeStack c1, LinearTreeStack c2)
{
    return makeLinearTreeStack(logicalAND(c1.distance, c2.distance), interpolateColorsWithAlpha(c1.color,c2.color));
}


float logicalOR(float d1, float d2)
{
    return min(d1, d2);
}

LinearTreeStack logicalORWithColor(LinearTreeStack c1, LinearTreeStack c2)
{
    return makeLinearTreeStack(logicalOR(c1.distance, c2.distance), c1.distance < c2.distance ? c1.color : c2.color);
}

float logicalNOT(float d)
{
    return -d;
}

LinearTreeStack logicalNOTWithColor(LinearTreeStack l)
{
    return makeLinearTreeStack(logicalNOT(l.distance), float4(l.color.rgb,0.0f));
}

float getDistanceCirlce(float3 p)
{
    return length(p) - 0.5f;
}

float getDistanceTorus(float3 p, float2 r1r2)
{
    float2 q = float2(length(p.xz) - r1r2.x, p.y);
    return length(q) - r1r2.y;
}

float smoothIntersectSDF(float d1, float d2, float k)
{
    float h = clamp(0.5 - 0.5 * (d1 - d2) / k, 0., 1.);
    return lerp(d1, d2, h) + k * h * (1. - h);
}
 
float smoothUnionSDF(float d1, float d2, float k)
{
    float h = clamp(0.5 + 0.5 * (d1 - d2) / k, 0., 1.);
    return lerp(d1, d2, h) - k * h * (1. - h);
}
 
float smoothDifferenceSDF(float d1, float d2, float k)
{
    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0., 1.);
    return lerp(d1, -d2, h) + k * h * (1. - h);
}

LinearTreeStack logicalsmoothDifferenceWithColor(LinearTreeStack c1, LinearTreeStack c2, float k)
{
    return makeLinearTreeStack(logicalAND(c1.distance, c2.distance), interpolateColorsWithAlpha(c1.color, c2.color));
}

float getDistanceCube(float3 p,float3 s)
{
    float3 q = abs(p) - s;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float getDistanceCoordinateGrid(float3 p)
{
    float3 q = abs(p) - 0.5;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}



//LinearTreeStack pop()
//{
//    return stackContext[stackPointer--];
//}

//void push(LinearTreeStack e)
//{
//    stackContext[stackPointer++] = e;
//}

//LinearTreeStack evaluateNode(GeneralTreeElement element, float3 position)
//{
//    LinearTreeStack c1;
//    LinearTreeStack c2;
//    LinearTreeStack ret;
//    [branch]
//    switch (element.nodeType)
//    {
//    case 0: //_OR
//        c1 = pop();
//        c2 = pop();
//        ret = (makeLinearTreeStack(logicalAND(c1.distance, c2.distance), float4(1.0f, 0.0f, 0.0f, 1.0f)));
//        break;
//    case 1: //_AND
//        c1 = pop();
//        c2 = pop();
//        ret = (makeLinearTreeStack(logicalAND(c1.distance, c2.distance), float4(1.0f, 0.0f, 0.0f, 1.0f)));
//        break;
//    case 3: //_SPHERE
//        ret = makeLinearTreeStack
//        (getDistanceCirlce(mul(element.translation, float4(position, 1.0)).xyz, element.a.x),
//         float4(element.color, 1.0f));
//        break;
//    case 4: //_TORUS
//        ret = makeLinearTreeStack
//        (getDistanceTorus(mul(element.translation, float4(position, 1.0)).xyz, element.a.xy),
//         float4(element.color, 1.0f));
//        break;
//    default:
//        ret = makeLinearTreeStack(0.0f, float4(1.0f, 0.0f, 1.0f, 1.0f));
//        break;
//    }
//    return ret;
//}

//float getDistanceFromTree(float3 p)
//{
//    GeneralTreeElement element;
//    for (uint i = 0; i < 3; i++)
//    {
//        element = distanceTree[i];
//        push(evaluateNode(element, p));
//    }
//    return pop().distance;
//}

LinearTreeStack getDistanceFromTreeCompact(float3 position)
{
    LinearTreeStack stackContext[25];
    int stackPointer = 0;
    GeneralTreeElement element;
    for (uint i = 0; i < distanceTreeLength; i++)
    {
        element = distanceTree[i];
        LinearTreeStack c1;
        LinearTreeStack c2;
        [branch]
        switch (element.nodeType)
        {
            case 0: //_OR
                c1 = stackContext[--stackPointer];
                c2 = stackContext[--stackPointer];
                stackContext[stackPointer++] = logicalORWithColor(c1,c2);
                break;
            case 1: //_AND
                c1 = stackContext[--stackPointer];
                c2 = stackContext[--stackPointer];
                stackContext[stackPointer++] = logicalANDWithColor(c1, c2);
                break;
            case 2: //_NOT
                c1 = stackContext[--stackPointer];
                stackContext[stackPointer++] = logicalNOTWithColor(c1);
                break;
            case 3: //_SPHERE
                stackContext[stackPointer++] = (makeLinearTreeStack(getDistanceCirlce(mul(element.translation, float4(position, 1.0)).xyz), float4(element.color, 1.0f)));
                break;
            case 4: //_TORUS
                stackContext[stackPointer++] = (makeLinearTreeStack(getDistanceTorus(mul(element.translation, float4(position, 1.0)).xyz, element.a.xy), float4(element.color, 1.0f)));
                break;
            case 5: //_SMOOTHINTERSECTS
                c1 = stackContext[--stackPointer];
                c2 = stackContext[--stackPointer];
                stackContext[stackPointer++] = logicalsmoothDifferenceWithColor(c1, c2, element.a.x);
                break;
            case 6: //_SMOOTHUNION
                c1 = stackContext[--stackPointer];
                c2 = stackContext[--stackPointer];
                stackContext[stackPointer++] = (makeLinearTreeStack(smoothUnionSDF(c1.distance, c2.distance, element.a.x), float4(1.0f, 0.0f, 0.0f, 1.0f)));
                break;
            case 7: //_SMOOTHDIFFERENCE
                c1 = stackContext[--stackPointer];
                c2 = stackContext[--stackPointer];
                stackContext[stackPointer++] = (makeLinearTreeStack(smoothDifferenceSDF(c1.distance, c2.distance, element.a.x), float4(1.0f, 0.0f, 0.0f, 1.0f)));
                break;
            case 8: //_CUBE
                stackContext[stackPointer++] = (makeLinearTreeStack(getDistanceCube(mul(element.translation, float4(position, 1.0)).xyz,element.a),
         float4(element.color, 1.0f)));
                break;
            default:
                stackContext[stackPointer++] = (makeLinearTreeStack(0.0f, float4(1.0f, 0.0f, 1.0f, 1.0f)));
                break;
        }
    }
    return stackContext[stackPointer - 1];
}
float getDistance(float3 p)
{
    return getDistanceFromTreeCompact(p).distance;
}
LinearTreeStack getDistanceAndMaterialColor(float3 p)
{
    return getDistanceFromTreeCompact(p);
}

float3 reflectRay(float3 ray, float3 surfaceNormal)
{
    return ray - 2.0f * dot(ray, surfaceNormal) * surfaceNormal;
}
float getAngleBetweenNormalized(float3 ray1, float3 ray2)
{
    return acos(dot(ray1, ray2));
}

float3 getSurfaceNormal(float3 p)
{
    return normalize(getDistance(p) -
        float3(
            getDistance(p - float3(marchEpsilon, 0, 0)),
            getDistance(p - float3(0, marchEpsilon, 0)),
            getDistance(p - float3(0, 0, marchEpsilon))
        ));
}

float3 sampleSkybox(float3 direction)
{
    float theta = acos(direction.y) / -PI;
    float phi = atan2(direction.x, direction.z) / -PI * 0.5f;
    return _Skybox.SampleLevel(sampler_Skybox, float2(phi, theta), 0);
}

float3 calculatePhongColor(float3 materialColor,float3 surfaceNormal,float3 viewDirection,float3 toLightDirection,float illumination,float shininess)
{
    float3 colorOut = materialColor.rgb * ambientFactor; //ambient
    colorOut += materialColor.rgb * lightColor * max(0.0f, dot(surfaceNormal, toLightDirection)) * illumination; //diffuse
    float3 halfwayVector = normalize((-viewDirection + toLightDirection) / 2.0f);
    colorOut += materialColor.rgb * lightColor * max(0.0f, ceil(dot(surfaceNormal, toLightDirection))) * pow(max(0.0f, dot(surfaceNormal, halfwayVector)), shininess) * illumination; //specular
    return colorOut;
}

float4 AddColorToHalfOfRest(float4 colorIn, float3 colorToAdd)
{
    float halfOfRest = (1.0f - colorIn.a) * (1.0f - shininess);
    float3 colorOut = colorIn.rgb * colorIn.a;
    colorOut += colorToAdd * halfOfRest;
    float newTotal = colorIn.a + halfOfRest;
    return float4(colorOut / newTotal, newTotal);
}

float4 CastRay(float3 origin, float3 direction)
{
    bool finished = false;
    float3 marchPosition = origin;
    float3 marchDirection = normalize(direction);
    float3 hitPoint;
    float3 hitDirection;
    LinearTreeStack hitContext;
    float3 hitSurfaceNormal;
    float distanceToLight;
    int iterations = 0;
    int reflections=0;
    float smallestDistance = 1000000.0f;
    int marchState=0;
    float penumbraFactor = 100000000.0f;
    float4 colorOut = float4(0,0,0,0);
    do
    {
        LinearTreeStack context = getDistanceAndMaterialColor(marchPosition);
        float distance = context.distance;
        if (distance < marchEpsilon)
        {
            //return float4(1.0, 0, 0, 1.0);
            //return float4(getSurfaceNormal(marchPosition), 1.0f);
            //return float4(calculatePhongColor(context.color.rgb, getSurfaceNormal(marchPosition), marchDirection, normalize(lightPosition - marchPosition), shininess), 1.0f);
            if (marchState == 0)
            {
                hitPoint = marchPosition;
                hitDirection = marchDirection;
                hitContext=context;
                hitSurfaceNormal = getSurfaceNormal(marchPosition);
                marchDirection = normalize(lightPosition - marchPosition);
                marchState = 1;
                penumbraFactor = 100000000.0f;
                distance = shadowStartDistance;

            }
            else
            {
                //return float4(length(marchPosition - hitPoint), length(marchPosition - hitPoint), length(marchPosition - hitPoint),1.0);
                //return float4(marchDirection, 1.0);
                float3 color = calculatePhongColor(hitContext.color.rgb, hitSurfaceNormal, hitDirection, marchDirection, 0.0, shininess);
                colorOut = AddColorToHalfOfRest(colorOut, color);
                if (++reflections > maxReflections)
                {
                    return colorOut;
                }
                marchPosition = hitPoint;
                marchDirection = reflectRay(hitDirection, hitSurfaceNormal);
                distance = marchEpsilon * 2.0f;
                marchState = 0;

            }
            
        }     
        else if (marchState == 1)
        {
            float distanceFromHitPoint = length(marchPosition - hitPoint);
            penumbraFactor = min(penumbraFactor, softShadowFactor * distance / distanceFromHitPoint);
            if (length(lightPosition - hitPoint) < distanceFromHitPoint)
            {
                float3 color = calculatePhongColor(hitContext.color.rgb, hitSurfaceNormal, hitDirection, marchDirection, min(1.0f, penumbraFactor), shininess);
                colorOut = AddColorToHalfOfRest(colorOut, color);
                if (++reflections > maxReflections)
                {
                    return colorOut;
                }
                marchPosition = hitPoint;
                marchDirection = reflectRay(hitDirection, hitSurfaceNormal);
                distance = marchEpsilon * 2.0f;
                marchState = 0;
            }
            
        }
        
        
        
        marchPosition += (marchDirection * distance);
        if (smallestDistance > distance)
        {
            smallestDistance = distance;
        }

        if (iterations > maxIterations)
        {
            return float4(1.0, 0.0, 1.0, 1.0);
        }
        if (length(marchPosition) > 1000.0f)
        {
            return AddColorToHalfOfRest(colorOut, sampleSkybox(marchDirection));
        }
        iterations++;
    }
    while (!finished);
    return float4(direction, 1.0);
}


float3 calculateViewRay(float2 pixelCoordinate, float isRightEye)
{
    return mul(viewFrustrum, float4(pixelCoordinate.x, pixelCoordinate.y, 1.0f, isRightEye)).xyz;
}


[numthreads(8, 8, 1)]
void SideBySide(uint3 id : SV_DispatchThreadID)
{
    uint2 pixelCoordinate = id.xy;
    float3 eyePosition;
    float isRightEye;
    if (pixelCoordinate.x < resolution.x / 2)
    {
        eyePosition = leftEyePosition;
        isRightEye = 0.0f;
    }
    else
    {
        eyePosition = rightEyePosition;
        isRightEye = 1.0f;
    }
    float2 realtiveCoordinate = float2(pixelCoordinate.x % (resolution.x / 2) / (float) (resolution.x / 2),
                                       pixelCoordinate.y / (float) resolution.y);
    float3 directionRay = calculateViewRay(realtiveCoordinate, isRightEye);
    float4 color = CastRay(eyePosition, directionRay);

    textureOut[id.xy] = color;
}

[numthreads(8, 8, 1)]
void LeftEyeOnly(uint3 id : SV_DispatchThreadID)
{
    uint2 pixelCoordinate = id.xy;
    float2 realtiveCoordinate = float2(pixelCoordinate.x / (float) resolution.x,
                                       pixelCoordinate.y / (float) resolution.y);
    float3 directionRay = calculateViewRay(realtiveCoordinate, 0.0f);
    float4 color = CastRay(leftEyePosition, directionRay);

    textureOut[id.xy] = color;
}

[numthreads(8, 8, 1)]
void AntiAliasing(uint3 id : SV_DispatchThreadID)
{
    float4 color;
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            uint2 pixelCoordinate = id.xy;
            float2 realtiveCoordinate = float2((pixelCoordinate.x + 0.25f * i - 0.375f) / (float) resolution.x,
                                       (pixelCoordinate.y + 0.25f * j - 0.375f) / (float) resolution.y);
            float3 directionRay = calculateViewRay(realtiveCoordinate, 0.0f);
            color += CastRay(leftEyePosition, directionRay);
        }
    }

    textureOut[id.xy] = color/16;
}
