// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel SideBySide
#pragma enable_d3d11_debug_symbols

RWTexture2D<float4> textureOut;
uint2 resolution;
float4x4 viewFrustrum;
float3 rightEyePosition;
float3 leftEyePosition;
float normalEpsilon = 0.001f;
float marchEpsilon = 0.001f;
float circleSize = 2.0f;
int maxIterations = 500000;

const float PI = 3.14159265359f;

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

    textureOut[id.xy] = float4(id.x & id.y, (id.x & 15) / 15.0, (id.y & 15) / 15.0, 0.0);
}

float getDistance(float3 p)
{
    //return (length(p) - circleSize); //circle
    
    //torus
    float2 q = float2(length(p.xz) - circleSize, p.y);
    return length(q) - circleSize / 6;
}

float3 getSurfaceNormal(float3 p)
{
    return normalize(getDistance(p) -
    float3(
        getDistance(p - float3(marchEpsilon, 0, 0)),
        getDistance(p - float3(0, marchEpsilon, 0)),
        getDistance(p - float3(0, 0, marchEpsilon))
    ));
    
    //float2 e = float2(1e-2, 0);
    //float3 n = getDistance(p) - float3(
    //            getDistance(p - e.xyy),
    //            getDistance(p - e.yxy),
    //            getDistance(p - e.yyx)
    //            );
    //return normalize(n);
}

float4 CastRay(float3 origin, float3 direction)
{
    bool finished = false;
    float3 marchPosition = origin;
    float3 marchDirection = normalize(direction);
    int iterations = 0;
    float smallestDistance = 1000000.0f;
    do
    {
        float distance = getDistance(marchPosition);
        if (distance < marchEpsilon)
        {
            //return float4(1.0, 0, 0, 1.0);
            return float4(getSurfaceNormal(marchPosition), 1.0f);
        }
        marchPosition += (marchDirection * distance);
        if (smallestDistance > distance)
        {
            smallestDistance = distance;
        }

        if (iterations > maxIterations)
        {
            return float4(smallestDistance, smallestDistance, smallestDistance, 1.0);
        }

        iterations++;
    }
    while (!finished);
    return float4(direction, 1.0);
    
    
    //float3 marchDirection = normalize(direction);
    //float4 colorOut = float4(1.0f, 1.0f, 1.0f, 1.0f);
    //float3 marchPosition = origin;
    //float distance = 0.0f;
    //float minDistance = 0;
    //for (int i = 0; i <= circleSize; i++)
    //{
    //    minDistance += 1 / 10.0f;

    //}
    //float normalizedDistance = minDistance ;
    //colorOut.rgb = normalizedDistance;
    //return colorOut;

    //float angleToOrigin = acos(dot(normalize(direction), normalize(-origin)));
    //angleToOrigin = angleToOrigin / PI;
    //float3 marchPosition = origin;
    //float distance = 0.0f;
    //float minDistance = 1000.0f;
    
    //for (int i = 0; i <= circleSize; i++)
    //{
    //    float distance = getDistance(origin + circleSize * normalize(direction));
    //    minDistance = min(minDistance, distance);

    //}
    //return float4(angleToOrigin,angleToOrigin,angleToOrigin, 1.0);
}


float3 calculateViewRay(float2 pixelCoordinate, float isRightEye)
{
    return mul(viewFrustrum, float4(pixelCoordinate.x, pixelCoordinate.y, 1.0f, isRightEye)).xyz;
}

[numthreads(8, 8, 1)]
void SideBySide(uint3 id : SV_DispatchThreadID)
{
    uint2 pixelCoordinate = id.xy;
    float3 eyePosition;
    float isRightEye;
    if (pixelCoordinate.x < resolution.x / 2)
    {
        eyePosition = leftEyePosition;
        isRightEye = 0.0f;
    }
    else
    {
        eyePosition = rightEyePosition;
        isRightEye = 1.0f;
    }
    float2 realtiveCoordinate = float2(pixelCoordinate.x % (resolution.x / 2) / (float) (resolution.x / 2), pixelCoordinate.y / (float) resolution.y);
    float3 directionRay = calculateViewRay(realtiveCoordinate, isRightEye);
    float4 color = CastRay(eyePosition, directionRay);
    
    textureOut[id.xy] = color;
}
[numthreads(8, 8, 1)]
void LeftEyeOnly(uint3 id : SV_DispatchThreadID)
{
    uint2 pixelCoordinate = id.xy;
    float3 eyePosition;
    float isRightEye;
    if (pixelCoordinate.x < resolution.x / 2)
    {
        eyePosition = leftEyePosition;
        isRightEye = 0.0f;
    }
    else
    {
        eyePosition = rightEyePosition;
        isRightEye = 1.0f;
    }
    float2 realtiveCoordinate = float2(pixelCoordinate.x % (resolution.x / 2) / (float) (resolution.x / 2), pixelCoordinate.y / (float) resolution.y);
    float3 directionRay = calculateViewRay(realtiveCoordinate, isRightEye);
    float4 color = CastRay(eyePosition, directionRay);
    
    textureOut[id.xy] = color;
}
